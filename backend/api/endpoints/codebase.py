"""
Codebase Analysis API endpoints.

This module provides:
- Codebase analysis triggering and status endpoints
- Impact analysis endpoints
"""

import logging
import secrets
from typing import Optional

from fastapi import APIRouter, Depends, HTTPException, Query, status
from sqlalchemy.ext.asyncio import AsyncSession

from backend.api.dependencies import get_current_user, get_db_session
from backend.api.schemas.codebase import (
    CodebaseAnalysisCreate,
    CodebaseAnalysisResponse,
    CodebaseAnalysisResultResponse,
    GitHubOAuthAuthorizeResponse,
    GitHubOAuthTokenExchangeRequest,
    GitHubOAuthTokenResponse,
    GitHubRepositoryListResponse,
    GitHubRepositorySummary,
    GitLabOAuthAuthorizeResponse,
    GitLabOAuthTokenExchangeRequest,
    GitLabOAuthTokenResponse,
    GitLabProjectListResponse,
    GitLabProjectSummary,
    ImpactAnalysisCreate,
    ImpactAnalysisResponse,
)
from backend.services.codebase_analysis_service import (
    CodebaseAnalysisService,
    CodebaseAnalysisNotFoundError,
)
from backend.services.github_oauth_service import (
    GitHubOAuthService,
    GitHubOAuthError,
    GitHubOAuthConfigError,
    GitHubRepositoryAccessError,
)
from backend.services.gitlab_oauth_service import (
    GitLabOAuthService,
    GitLabOAuthError,
    GitLabOAuthConfigError,
    GitLabRepositoryAccessError,
)
from backend.services.repository_clone_service import (
    RepositoryCloneService,
    RepositoryCloneError,
)
from backend.services.project_service import ProjectService

logger = logging.getLogger(__name__)

router = APIRouter()


# ======================
# Codebase Analysis
# ======================


@router.get(
    "/codebase/github/oauth/authorize",
    response_model=GitHubOAuthAuthorizeResponse,
    tags=["Codebase Analysis"],
    summary="Get GitHub OAuth authorization URL for repository access",
)
async def get_github_oauth_authorize_url(
    redirect_uri: str = Query(..., description="Frontend callback URI for GitHub OAuth"),
    state: Optional[str] = Query(None, description="Optional state token; autogenerated if omitted"),
    scope: str = Query("repo read:user user:email", description="OAuth scope for repository access"),
    current_user: dict = Depends(get_current_user),
):
    """
    Generate GitHub OAuth authorization URL for brownfield repository access.
    """
    del current_user
    try:
        resolved_state = state or secrets.token_urlsafe(32)
        service = GitHubOAuthService()
        auth_url = service.get_authorization_url(
            redirect_uri=redirect_uri,
            state=resolved_state,
            scope=scope,
        )
        return GitHubOAuthAuthorizeResponse(
            provider="github",
            auth_url=auth_url,
            state=resolved_state,
            scope=scope,
        )
    except GitHubOAuthConfigError as e:
        raise HTTPException(status_code=500, detail=str(e))
    except Exception as e:
        logger.error(f"Error creating GitHub OAuth URL: {e}")
        raise HTTPException(status_code=500, detail="Failed to generate GitHub OAuth URL")


@router.post(
    "/codebase/github/oauth/token",
    response_model=GitHubOAuthTokenResponse,
    tags=["Codebase Analysis"],
    summary="Exchange GitHub OAuth code for repository access token",
)
async def exchange_github_oauth_token(
    request: GitHubOAuthTokenExchangeRequest,
    current_user: dict = Depends(get_current_user),
):
    """
    Exchange GitHub OAuth authorization code for access token.
    """
    del current_user
    service = GitHubOAuthService()
    try:
        token_data = await service.exchange_code_for_token(
            code=request.code,
            redirect_uri=request.redirect_uri,
        )
        return GitHubOAuthTokenResponse(
            access_token=token_data.get("access_token"),
            token_type=token_data.get("token_type", "bearer"),
            scope=token_data.get("scope"),
        )
    except GitHubOAuthConfigError as e:
        raise HTTPException(status_code=500, detail=str(e))
    except GitHubOAuthError as e:
        raise HTTPException(status_code=401, detail=str(e))
    except Exception as e:
        logger.error(f"Error exchanging GitHub OAuth token: {e}")
        raise HTTPException(status_code=500, detail="Failed to exchange GitHub OAuth token")


@router.get(
    "/codebase/github/repositories",
    response_model=GitHubRepositoryListResponse,
    tags=["Codebase Analysis"],
    summary="List GitHub repositories accessible via OAuth token",
)
async def list_github_repositories(
    access_token: str = Query(..., description="GitHub OAuth access token"),
    visibility: str = Query("all", pattern="^(all|public|private)$"),
    page: int = Query(1, ge=1),
    per_page: int = Query(30, ge=1, le=100),
    current_user: dict = Depends(get_current_user),
):
    """
    List repositories available to the authenticated GitHub OAuth token.
    """
    del current_user
    service = GitHubOAuthService()
    try:
        repositories = await service.list_repositories(
            access_token=access_token,
            visibility=visibility,
            page=page,
            per_page=per_page,
        )
        items = [
            GitHubRepositorySummary(
                id=repo.get("id"),
                name=repo.get("name"),
                full_name=repo.get("full_name"),
                private=repo.get("private", False),
                html_url=repo.get("html_url"),
                default_branch=repo.get("default_branch"),
                visibility=repo.get("visibility"),
            )
            for repo in repositories
        ]
        return GitHubRepositoryListResponse(
            repositories=items,
            total=len(items),
        )
    except GitHubOAuthError as e:
        raise HTTPException(status_code=401, detail=str(e))
    except Exception as e:
        logger.error(f"Error listing GitHub repositories: {e}")
        raise HTTPException(status_code=500, detail="Failed to list GitHub repositories")


@router.get(
    "/codebase/gitlab/oauth/authorize",
    response_model=GitLabOAuthAuthorizeResponse,
    tags=["Codebase Analysis"],
    summary="Get GitLab OAuth authorization URL for repository access",
)
async def get_gitlab_oauth_authorize_url(
    redirect_uri: str = Query(..., description="Frontend callback URI for GitLab OAuth"),
    state: Optional[str] = Query(None, description="Optional state token; autogenerated if omitted"),
    scope: str = Query("read_user read_api", description="OAuth scope for repository access"),
    base_url: Optional[str] = Query(
        None,
        description="Optional GitLab base URL for self-hosted instances",
    ),
    current_user: dict = Depends(get_current_user),
):
    """
    Generate GitLab OAuth authorization URL for brownfield repository access.
    Supports cloud and self-hosted GitLab.
    """
    del current_user
    try:
        resolved_state = state or secrets.token_urlsafe(32)
        service = GitLabOAuthService()
        auth_url, resolved_base = service.get_authorization_url(
            redirect_uri=redirect_uri,
            state=resolved_state,
            scope=scope,
            base_url=base_url,
        )
        return GitLabOAuthAuthorizeResponse(
            provider="gitlab",
            auth_url=auth_url,
            state=resolved_state,
            scope=scope,
            base_url=resolved_base,
        )
    except GitLabOAuthConfigError as e:
        raise HTTPException(status_code=500, detail=str(e))
    except Exception as e:
        logger.error(f"Error creating GitLab OAuth URL: {e}")
        raise HTTPException(status_code=500, detail="Failed to generate GitLab OAuth URL")


@router.post(
    "/codebase/gitlab/oauth/token",
    response_model=GitLabOAuthTokenResponse,
    tags=["Codebase Analysis"],
    summary="Exchange GitLab OAuth code for repository access token",
)
async def exchange_gitlab_oauth_token(
    request: GitLabOAuthTokenExchangeRequest,
    current_user: dict = Depends(get_current_user),
):
    """
    Exchange GitLab OAuth authorization code for access token.
    """
    del current_user
    service = GitLabOAuthService()
    try:
        token_data = await service.exchange_code_for_token(
            code=request.code,
            redirect_uri=request.redirect_uri,
            base_url=request.base_url,
        )
        return GitLabOAuthTokenResponse(
            access_token=token_data.get("access_token"),
            token_type=token_data.get("token_type", "bearer"),
            scope=token_data.get("scope"),
            created_at=token_data.get("created_at"),
        )
    except GitLabOAuthConfigError as e:
        raise HTTPException(status_code=500, detail=str(e))
    except GitLabOAuthError as e:
        raise HTTPException(status_code=401, detail=str(e))
    except Exception as e:
        logger.error(f"Error exchanging GitLab OAuth token: {e}")
        raise HTTPException(status_code=500, detail="Failed to exchange GitLab OAuth token")


@router.get(
    "/codebase/gitlab/projects",
    response_model=GitLabProjectListResponse,
    tags=["Codebase Analysis"],
    summary="List GitLab projects accessible via OAuth token",
)
async def list_gitlab_projects(
    access_token: str = Query(..., description="GitLab OAuth access token"),
    base_url: Optional[str] = Query(
        None,
        description="Optional GitLab base URL for self-hosted instances",
    ),
    page: int = Query(1, ge=1),
    per_page: int = Query(30, ge=1, le=100),
    current_user: dict = Depends(get_current_user),
):
    """
    List projects available to the authenticated GitLab OAuth token.
    """
    del current_user
    service = GitLabOAuthService()
    try:
        projects = await service.list_projects(
            access_token=access_token,
            base_url=base_url,
            page=page,
            per_page=per_page,
        )
        items = [
            GitLabProjectSummary(
                id=project.get("id"),
                name=project.get("name"),
                path_with_namespace=project.get("path_with_namespace"),
                private=project.get("visibility") == "private",
                web_url=project.get("web_url"),
                default_branch=project.get("default_branch"),
                visibility=project.get("visibility"),
            )
            for project in projects
        ]
        return GitLabProjectListResponse(
            projects=items,
            total=len(items),
        )
    except GitLabOAuthError as e:
        raise HTTPException(status_code=401, detail=str(e))
    except Exception as e:
        logger.error(f"Error listing GitLab projects: {e}")
        raise HTTPException(status_code=500, detail="Failed to list GitLab projects")


@router.post(
    "/codebase/analyze",
    response_model=CodebaseAnalysisResponse,
    status_code=status.HTTP_202_ACCEPTED,
    tags=["Codebase Analysis"],
    summary="Trigger codebase analysis",
)
async def trigger_codebase_analysis(
    request: CodebaseAnalysisCreate,
    current_user: dict = Depends(get_current_user),
    session: AsyncSession = Depends(get_db_session),
):
    """
    Trigger a new codebase analysis for a brownfield project.

    Requires Editor or Admin role in the workspace.
    """
    try:
        # Verify project exists and user has access
        project_service = ProjectService(session)
        project = await project_service.get_project_by_id(
            str(request.project_id),
            current_user.get("user_id")
        )

        # Check permission
        if project.workspace_id:
            from backend.services.workspace_service import WorkspaceService
            ws_service = WorkspaceService(session)
            await ws_service.check_permission(
                project.workspace_id,
                current_user.get("user_id"),
                ["editor", "admin"],
            )

        repository_url = (
            str(request.repository_url)
            if request.repository_url
            else (str(project.repository_url) if getattr(project, "repository_url", None) else None)
        )
        branch_name = request.branch_name
        commit_sha = None

        # Validate GitHub repository access if repository URL points to GitHub.
        if repository_url and "github.com" in repository_url.lower():
            github_service = GitHubOAuthService()
            repo_info = await github_service.verify_repository_access(
                repository_url=repository_url,
                access_token=request.github_access_token,
            )
            if not branch_name:
                branch_name = repo_info.get("default_branch")
        elif repository_url and (
            "gitlab" in repository_url.lower()
            or request.gitlab_access_token
            or request.gitlab_base_url
        ):
            gitlab_service = GitLabOAuthService()
            repo_info = await gitlab_service.verify_repository_access(
                repository_url=repository_url,
                access_token=request.gitlab_access_token,
                base_url=request.gitlab_base_url,
            )
            if not branch_name:
                branch_name = repo_info.get("default_branch")

        # Clone (or reuse cached) repository and resolve exact analyzed commit SHA.
        if repository_url:
            clone_service = RepositoryCloneService()
            clone_result = await clone_service.clone_or_get_cached(
                repository_url=repository_url,
                branch_name=branch_name,
                directory_scope=request.directory_scope,
                github_access_token=request.github_access_token,
                gitlab_access_token=request.gitlab_access_token,
                gitlab_base_url=request.gitlab_base_url,
            )
            if clone_result.branch_name:
                branch_name = clone_result.branch_name
            commit_sha = clone_result.commit_sha

        # Create analysis record
        analysis_service = CodebaseAnalysisService(session)
        analysis = await analysis_service.create_analysis(
            project_id=str(request.project_id),
            repository_url=repository_url,
            branch_name=branch_name,
            commit_sha=commit_sha,
        )

        # TODO: Trigger actual analysis (e.g., via Celery task or LangGraph agent)
        # For now, return the created analysis with pending status

        return CodebaseAnalysisResponse(
            id=str(analysis.id),
            project_id=str(analysis.project_id),
            status=analysis.status.value,
            repository_url=analysis.repository_url,
            branch_name=analysis.branch_name,
            message="Analysis queued successfully",
        )

    except (
        GitHubRepositoryAccessError,
        GitHubOAuthError,
        GitLabRepositoryAccessError,
        GitLabOAuthError,
    ) as e:
        raise HTTPException(status_code=403, detail=str(e))
    except RepositoryCloneError as e:
        raise HTTPException(status_code=400, detail=str(e))
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error triggering analysis: {e}")
        raise HTTPException(
            status_code=500, detail="Failed to trigger analysis"
        )


@router.get(
    "/codebase/analyses/{analysis_id}",
    response_model=CodebaseAnalysisResultResponse,
    tags=["Codebase Analysis"],
    summary="Get analysis results",
)
async def get_analysis_results(
    analysis_id: str,
    current_user: dict = Depends(get_current_user),
    session: AsyncSession = Depends(get_db_session),
):
    """
    Get the results of a codebase analysis.
    """
    try:
        analysis_service = CodebaseAnalysisService(session)
        analysis = await analysis_service.get_analysis_by_id(analysis_id)

        # Verify user has access to the project
        project_service = ProjectService(session)
        await project_service.get_project_by_id(
            str(analysis.project_id),
            current_user.get("user_id")
        )

        return CodebaseAnalysisResultResponse(
            id=str(analysis.id),
            project_id=str(analysis.project_id),
            status=analysis.status.value,
            repository_url=analysis.repository_url,
            languages=analysis.languages or [],
            language_stats=analysis.language_stats or {},
            total_loc=analysis.total_loc,
            file_count=analysis.file_count,
            architecture_summary=analysis.architecture_summary,
            component_inventory=analysis.component_inventory or [],
            dependency_graph=analysis.dependency_graph or {},
            detected_patterns=analysis.detected_patterns or [],
            findings=analysis.findings or [],
            created_at=analysis.created_at.isoformat() if analysis.created_at else None,
            completed_at=analysis.completed_at.isoformat() if analysis.completed_at else None,
            error_message=analysis.error_message,
        )

    except CodebaseAnalysisNotFoundError:
        raise HTTPException(
            status_code=404, detail="Analysis not found"
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting analysis: {e}")
        raise HTTPException(
            status_code=500, detail="Failed to get analysis"
        )


@router.get(
    "/projects/{project_id}/codebase/analyses",
    response_model=list[CodebaseAnalysisResponse],
    tags=["Codebase Analysis"],
    summary="List project analyses",
)
async def list_project_analyses(
    project_id: str,
    current_user: dict = Depends(get_current_user),
    session: AsyncSession = Depends(get_db_session),
):
    """
    List all codebase analyses for a project.
    """
    try:
        # Verify user has access
        project_service = ProjectService(session)
        project = await project_service.get_project_by_id(
            project_id,
            current_user.get("user_id")
        )

        # Check permission
        if project.workspace_id:
            from backend.services.workspace_service import WorkspaceService
            ws_service = WorkspaceService(session)
            await ws_service.check_permission(
                project.workspace_id,
                current_user.get("user_id"),
                ["viewer", "editor", "admin"],
            )

        # Get latest analysis
        analysis_service = CodebaseAnalysisService(session)
        latest_analysis = await analysis_service.get_latest_analysis(project_id)

        if not latest_analysis:
            return []

        return [CodebaseAnalysisResponse(
            id=str(latest_analysis.id),
            project_id=str(latest_analysis.project_id),
            status=latest_analysis.status.value,
            repository_url=latest_analysis.repository_url,
            branch_name=latest_analysis.branch_name,
            created_at=latest_analysis.created_at.isoformat() if latest_analysis.created_at else None,
        )]

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error listing analyses: {e}")
        raise HTTPException(
            status_code=500, detail="Failed to list analyses"
        )


# ======================
# Impact Analysis
# ======================


@router.post(
    "/projects/{project_id}/impact-analysis",
    response_model=ImpactAnalysisResponse,
    status_code=status.HTTP_202_ACCEPTED,
    tags=["Impact Analysis"],
    summary="Trigger impact analysis",
)
async def trigger_impact_analysis(
    project_id: str,
    request: ImpactAnalysisCreate,
    current_user: dict = Depends(get_current_user),
    session: AsyncSession = Depends(get_db_session),
):
    """
    Trigger an impact analysis for a proposed change.

    Requires Editor or Admin role.
    """
    try:
        # Verify project exists and user has access
        project_service = ProjectService(session)
        project = await project_service.get_project_by_id(
            project_id,
            current_user.get("user_id")
        )

        # Check permission
        if project.workspace_id:
            from backend.services.workspace_service import WorkspaceService
            ws_service = WorkspaceService(session)
            await ws_service.check_permission(
                project.workspace_id,
                current_user.get("user_id"),
                ["editor", "admin"],
            )

        # Get latest codebase analysis
        analysis_service = CodebaseAnalysisService(session)
        latest_analysis = await analysis_service.get_latest_analysis(project_id)

        if not latest_analysis:
            raise HTTPException(
                status_code=400,
                detail="No codebase analysis found. Please run analysis first."
            )

        # Create impact analysis record
        impact = await analysis_service.create_impact_analysis(
            codebase_analysis_id=str(latest_analysis.id),
            project_id=project_id,
            change_description=request.change_description,
        )

        # TODO: Trigger actual impact analysis

        return ImpactAnalysisResponse(
            id=str(impact.id),
            codebase_analysis_id=str(impact.codebase_analysis_id),
            project_id=str(impact.project_id),
            change_description=impact.change_description,
            status="pending",
            message="Impact analysis queued successfully",
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error triggering impact analysis: {e}")
        raise HTTPException(
            status_code=500, detail="Failed to trigger impact analysis"
        )


@router.get(
    "/impact-analyses/{impact_id}",
    response_model=ImpactAnalysisResponse,
    tags=["Impact Analysis"],
    summary="Get impact analysis results",
)
async def get_impact_analysis(
    impact_id: str,
    current_user: dict = Depends(get_current_user),
    session: AsyncSession = Depends(get_db_session),
):
    """
    Get the results of an impact analysis.
    """
    try:
        analysis_service = CodebaseAnalysisService(session)
        impact = await analysis_service.get_impact_analysis(impact_id)

        # Verify user has access to the project
        project_service = ProjectService(session)
        await project_service.get_project_by_id(
            str(impact.project_id),
            current_user.get("user_id")
        )

        return ImpactAnalysisResponse(
            id=str(impact.id),
            codebase_analysis_id=str(impact.codebase_analysis_id),
            project_id=str(impact.project_id),
            change_description=impact.change_description,
            affected_files=impact.affected_files or [],
            affected_components=impact.affected_components or [],
            risk_level=impact.risk_level.value if impact.risk_level else None,
            risk_factors=impact.risk_factors or [],
            breaking_changes=impact.breaking_changes or [],
            downstream_dependencies=impact.downstream_dependencies or [],
            rollback_procedure=impact.rollback_procedure,
            change_plan=impact.change_plan or [],
            created_at=impact.created_at.isoformat() if impact.created_at else None,
        )

    except CodebaseAnalysisNotFoundError:
        raise HTTPException(
            status_code=404, detail="Impact analysis not found"
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error getting impact analysis: {e}")
        raise HTTPException(
            status_code=500, detail="Failed to get impact analysis"
        )


@router.get(
    "/projects/{project_id}/impact-analyses",
    response_model=list[ImpactAnalysisResponse],
    tags=["Impact Analysis"],
    summary="List project impact analyses",
)
async def list_impact_analyses(
    project_id: str,
    current_user: dict = Depends(get_current_user),
    session: AsyncSession = Depends(get_db_session),
):
    """
    List all impact analyses for a project.
    """
    try:
        # Verify user has access
        project_service = ProjectService(session)
        project = await project_service.get_project_by_id(
            project_id,
            current_user.get("user_id")
        )

        # Check permission
        if project.workspace_id:
            from backend.services.workspace_service import WorkspaceService
            ws_service = WorkspaceService(session)
            await ws_service.check_permission(
                project.workspace_id,
                current_user.get("user_id"),
                ["viewer", "editor", "admin"],
            )

        # Get latest codebase analysis and its impacts
        analysis_service = CodebaseAnalysisService(session)
        latest_analysis = await analysis_service.get_latest_analysis(project_id)

        if not latest_analysis:
            return []

        # This is simplified - in production, you'd want pagination
        return []

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Error listing impact analyses: {e}")
        raise HTTPException(
            status_code=500, detail="Failed to list impact analyses"
        )
